# MEDS Format Support in SAT

This document explains how to use the Medical Event Data Standard (MEDS) format with SAT for survival analysis.

## Overview

The Medical Event Data Standard (MEDS) is a standardized format for healthcare data designed to facilitate portable analyses across different datasets. SAT now supports MEDS-formatted data, allowing you to leverage existing MEDS datasets for survival analysis.

## Requirements

To use MEDS format with SAT, you need the following additional dependencies:

- `pyarrow`: For reading Parquet files
- `fastparquet`: Alternative Parquet engine
- `femr` (optional): Python package for advanced MEDS processing

These dependencies are automatically included in the project configuration.

## New Features in MEDS Support

The latest MEDS parser implementation includes:

1. **Varying Length Histories**: Support for patients with varying lengths of medical histories based on their event times.
2. **Modality Vectors**: Each feature is classified as either categorical (0) or numerical (1).
3. **Numerics Vectors**: Standardized numeric values for features (1.0 for categorical features).
4. **Events List**: For multi-event analysis, an events list indicates which events occurred for each patient.
5. **Durations List**: Corresponding time-to-event values for each event type.
6. **Competing Risks**: Full support for competing risks with multiple event types.

## MEDS Format Structure

MEDS data is typically stored in Parquet format with a standardized schema:

- `patients`: Core patient information table
- Additional tables for different medical event types (e.g., `mortality`, `hospitalizations`)
- Standardized columns for patient IDs, timestamps, and event details

The synthetic MEDS generator creates multiple Parquet files:
- `synthetic_meds_patients.parquet`: Patient demographic and clinical features
- `synthetic_meds_mortality.parquet`: Mortality events with timestamps
- `synthetic_meds_hospitalizations.parquet`: Hospitalization events with timestamps
- And others like `diagnoses`, `medications`, etc.
- `synthetic_meds_metadata.json`: Information about the dataset tables

## Medical Labelers for MEDS Data

SAT provides specialized labelers for medical data in the MEDS format. These labelers include built-in parallel processing capabilities for efficiently handling large datasets by processing patients in parallel batches.

### Built-in Labelers

The following labelers are available:

1. **MortalityLabeler**: Identifies mortality events and creates time-to-event labels
2. **CompetingRiskLabeler**: Handles multiple competing events (like death and hospitalization)
3. **CustomEventLabeler**: Configurable labeler for custom event definitions
4. **RiskFactorLabeler**: Identifies risk factors from medical codes

Each labeler inherits from the `MedicalLabeler` base class, which provides parallel processing support.

### Parallel Processing Modes

All labelers support three processing modes:

1. **Serial**: Process patients one by one (for small datasets or debugging)
2. **Multiprocessing**: Process patients in parallel using Python's multiprocessing (default)
3. **Ray**: Distributed processing across multiple machines (if Ray is installed)

### Event List Generation

When multiple labelers are defined, the system generates event lists in the following way:

1. **Order-Preserving**: Events are added to the events list in the exact order of labeler definitions
2. **Consistent Length**: The events list will always be as long as there are labelers (excluding risk factor labelers)
3. **Matched Durations**: Each event has a corresponding duration value in the same position

This ensures that the order of events in the lists corresponds directly to the order of labelers in your config, making it easier to interpret the results and understand which events have occurred for each patient.

**Important Note on Event List Length**: The length of the events list (and corresponding durations list) is determined by the number of event-generating labelers in your configuration:
- **MortalityLabeler**, **CustomEventLabeler**, and **CompetingRiskLabeler** all contribute to the events list
- **RiskFactorLabeler** only contributes to the events list if it finds risk factors for a patient and is configured to do so
- The metadata will be updated to reflect all the event types generated by your labelers

### Configuration

Instead of using label definitions, you can now use custom labelers in your configuration:

```yaml
_target_: sat.data.dataset.parse_meds.meds
source: ${data_source}
processed_dir: ${modelhub}
train_ratio: 0.7
validation_ratio: 0.15
test_ratio: 0.15
n_bins: 20
encode: ordinal
strategy: quantile
name: ${dataset}
kfold: ${cv.kfold}
time_field: days
# Scaling options for numerical features
scale_numerics: true
scale_method: "standard"  # or "min_max"
min_scale_numerics: 1.0  # Used with min_max scaling

# Custom labelers for medical events
labelers:
  # Mortality labeler to identify death events
  - type: mortality
    name: death
    max_followup_days: 1095  # 3 years follow-up
    death_codes: ["SNOMED/419620001"]  # Using MEDS_DEATH_CODE
    enrollment_codes: ["ENROLLMENT"]
    
  # Hospitalization event labeler
  - type: custom_event
    name: hospitalization
    max_followup_days: 1095
    event_definition:
      codes: ["ENC_INPATIENT"]
    enrollment_codes: ["ENROLLMENT"]
      
  # Custom event labeler for complex event definitions
  - type: custom_event
    name: diabetes_complications
    max_followup_days: 1095
    event_definition:
      and:
        - codes: ["ICD10:E11"]  # Type 2 diabetes
        - or:
            - codes: ["ICD10:I50"]  # Heart failure
            - codes: ["ICD10:N18"]  # Kidney disease
    enrollment_codes: ["ENROLLMENT"]
            
  # Risk factor labeler to identify conditions
  - type: risk_factor
    name: risk_factors
    custom_codes:  # Optional additional codes
      icd10:
        hypertension: ["I15.9"]
        diabetes: ["E11"]
        heart_failure: ["I50"]
      rxnorm:
        diabetes: ["A10"]
```

This approach leverages SAT's labeling system to:
1. Extract events from the MEDS data using strongly typed schemas
2. Process data efficiently with parallel processing
3. Support flexible, custom event definitions
4. Process very large datasets that don't fit in memory
5. Ensure events are in the correct order corresponding to labeler definitions

## Deprecated Configuration (Legacy Support)

For backward compatibility, the system still supports the older configuration format that uses `label_definitions`:

```yaml
_target_: sat.data.dataset.parse_meds.meds
source: ${data_source}
processed_dir: ${modelhub}
train_ratio: 0.7
validation_ratio: 0.15
test_ratio: 0.15
n_bins: 20
encode: ordinal
strategy: quantile
name: ${dataset}
kfold: ${cv.kfold}
time_field: days
# Scaling options for numerical features
scale_numerics: true
scale_method: "standard"  # or "min_max"
min_scale_numerics: 1.0  # Used with min_max scaling
# Event definitions for competing risks (legacy approach)
label_definitions:
  - name: mortality
    positive_class: true
    table_name: mortality
    time_field: days
  - name: hospitalization
    positive_class: true
    table_name: hospitalizations
    time_field: days
```

However, it's recommended to use the new labelers-based approach for better control and performance.

## Processing MEDS Data

The standard SAT workflow applies to MEDS data:

1. **Prepare Data**:
   ```bash
   python -m sat.prepare_data experiments=synthetic_meds/survival data_source=/path/to/meds_dir dataset=my_meds
   ```

2. **Train Tokenizer**:
   ```bash
   python -m sat.train_tokenizer experiments=synthetic_meds/survival dataset=my_meds
   ```

3. **Train Label Transform**:
   ```bash
   python -m sat.train_labeltransform experiments=synthetic_meds/survival dataset=my_meds
   ```

4. **Fine-tune Model**:
   ```bash
   python -m sat.finetune experiments=synthetic_meds/survival dataset=my_meds
   ```

## Handling Multiple Event Types (Competing Risks)

The MEDS parser automatically handles multiple event types as competing risks:

1. Each event type (mortality, hospitalization, etc.) is assigned a unique integer code (starting from 1)
2. Code 0 is reserved for censored observations
3. Events are processed to create a proper time-to-event dataset with:
   - `events`: List of binary indicators for each event type (e.g., [0, 1, 0] means event type 2 occurred)
   - `durations`: List of times for each event type (e.g., [30, 25, 30] means event type 2 occurred at day 25)
   
For a patient with 3 possible event types who experienced event type 2 at day 100:
- `events` would be [0, 1, 0] (indicating event type 2 occurred)
- `durations` would be [100, 100, 100] (the time at which observation ended for all event types)

For a censored patient at day 50 with 3 possible event types:
- `events` would be [0, 0, 0] (no events occurred)
- `durations` would be [50, 50, 50] (censored at day 50 for all event types)

## Generating Synthetic MEDS Data

The provided synthetic MEDS data generator creates realistic healthcare data for testing:

```bash
python -m sat.data.dataset.generate_synthetic_meds --output data/synthetic_meds/synthetic_meds.parquet
```

Options:
- `--num_patients`: Number of patients to generate (default: 10000)
- `--seed`: Random seed for reproducibility
- `--output`: Output path for the data

## Efficient Processing of Large Datasets

Our framework now includes specialized support for processing very large MEDS datasets that may not fit in memory:

```python
from sat.data.dataset.medical_labelers import MortalityLabeler, ProcessingMode

# Initialize a labeler
mortality_labeler = MortalityLabeler(
    name="mortality_labeler",
    max_followup_days=1095
)

# Process a large dataset in chunks
mortality_labeler.process_large_dataset(
    events_path="/path/to/meds/data",  # Directory with parquet files
    output_path="/path/to/output",     # Where to save results
    mode=ProcessingMode.MULTIPROCESSING,
    n_jobs=8,                          # Number of parallel workers
    batch_size=1000,                   # Patients per batch
    patient_chunk_size=10000,          # Patients loaded at once
    show_progress=True
)
```

This approach:
1. Processes patients in chunks to limit memory usage
2. Uses parallel processing within each chunk
3. Saves intermediate results to disk
4. Combines all results at the end

For datasets that do fit in memory, you can use the parallel processing directly:

```python
import pandas as pd
from sat.data.dataset.medical_labelers import CompetingRiskLabeler, ProcessingMode

# Load events
events_df = pd.read_parquet("/path/to/events.parquet")

# Initialize a labeler
competing_risk_labeler = CompetingRiskLabeler(
    name="competing_risk_labeler",
    event_codes={
        "death": ["MEDS_DEATH"],
        "hospitalization": ["ENC_INPATIENT"],
    },
    max_followup_days=1095
)

# Process in parallel
results = competing_risk_labeler.parallel_label(
    events=events_df,
    mode=ProcessingMode.MULTIPROCESSING,
    n_jobs=8,
    batch_size=1000,
    show_progress=True
)
```

## Troubleshooting

Common issues and solutions:

- **Missing tables**: Check your MEDS data structure to ensure required tables are present
- **Time field not found**: Set the correct `time_field` in your configuration
- **Processing performance issues**: Try different processing modes and batch sizes
- **Memory errors**: Use the `process_large_dataset` method with appropriate chunk sizes
- **Polars import errors**: Install polars (`pip install polars`) for faster data processing
- **Ray import errors**: Install ray (`pip install ray`) for distributed processing

## Variable-Length Medical Histories

The MEDS parser captures variable-length patient histories through these derived features:

1. **History Length**: The number of medical events in a patient's history
2. **Event Count**: Total number of events per patient 
3. **Event Type Indicators**: Binary features showing which event types occurred (e.g., has_hospitalization, has_medication)
4. **Event Sequence**: Encoded sequence of the first three events that occurred
5. **Time Between Events**: Average time between consecutive events
6. **Event Density**: Number of events per time unit (indicates how frequently events occurred)

These features allow the model to incorporate information about the variable-length medical histories rather than just using the baseline patient characteristics. This better represents real-world healthcare data where patients have different numbers of medical events over varying time periods.

## Further Reading

- [FEMR Documentation](https://github.com/som-shahlab/femr)
- [MEDS Format Specification](https://github.com/som-shahlab/meds-format)